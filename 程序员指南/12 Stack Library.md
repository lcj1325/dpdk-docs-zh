# 12. 堆栈库

DPDK 的堆栈库提供了用于配置和使用有界指针堆栈的 API。

stack库提供了以下基本操作：

- 创建用户指定大小的唯一命名堆栈并使用用户指定的套接字，具有标准（基于锁）或无锁行为。
- 压入和弹出一批一个或多个堆栈对象（指针）。这些函数是多线程安全的。
- 通过名称查找指向堆栈的指针。
- 查询堆栈当前的深度和空闲条目数。

## 12.1.实现方式

该库支持两种类型的堆栈：标准（基于锁）和无锁。两种类型都使用同一组接口，但它们的实现不同。

### 12.1.1.基于锁的堆栈

基于锁的堆栈由连续的指针数组、当前索引和自旋锁组成。自旋锁使对堆栈的访问成为多线程安全的。

### 12.1.2.无锁堆栈

无锁堆栈由一个元素链表组成，每个元素包含一个数据指针和一个下一个指针，以及一个原子堆栈深度计数器。无锁属性意味着多个线程可以同时推送和弹出，并且一个线程在推送或弹出操作中被抢占/延迟不会阻碍任何其他线程的前进进度。

无锁出栈操作首先通过调整堆栈长度保留一个或多个列表元素，以确保出队操作成功而不会阻塞。然后，它通过遍历列表（从头部开始）然后摆动头部指针（也使用 CAS）来使指针出队。在遍历列表时，数据指针被记录在对象表中。

链表元素本身以无锁后进先出的方式维护，并在堆栈压入之前分配并在堆栈弹出之后释放。由于堆栈具有固定的最大深度，因此不需要动态创建这些元素。

通过将 `RTE_STACK_F_LF` 标志传递给 `rte_stack_create()` 来选择无锁行为。

#### 12.1.2.1.预防 ABA 问题

为了防止 ABA 问题，该算法堆栈使用 128 位比较和交换指令来自动更新堆栈顶部指针和修改计数器。ABA 问题可能在没有修改计数器的情况下发生，例如：
- 线程A读取头指针X并存储指向的列表元素。
- 其他线程修改该列表，使头指针再次变为 X，但其指向的数据与线程 A 读取的数据不同。
- 线程 A 通过比较和交换更改头指针并成功。

在这种情况下，线程 A 不会检测到列表已更改，并且会弹出陈旧数据并错误地更改头指针。通过添加一个在每次压入和弹出时更新的修改计数器作为比较和交换的一部分，即使头指针保持不变，该算法也可以检测列表何时更改。