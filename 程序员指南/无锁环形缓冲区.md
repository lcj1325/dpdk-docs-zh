# 无锁环形缓冲区

去年内核峰会和 Linux 管道工会议的成果之一是[创建一个低级环形缓冲区实现的计划](http://lwn.net/Articles/300992/)，该实现可以在 Linux 可用的各种内核和用户空间跟踪解决方案之间共享。公共环形缓冲区的一种实现作为 2.6.28 的一部分发布，但它有依赖锁，这影响了它的性能。最近，Steven Rostedt 提出了一种无锁环形缓冲区算法，该算法将消除写入锁定，这是跟踪的快速路径。

由于跟踪信息是在内核中收集的，因此需要非常快速地将其存储在某个地方，以便对观察到的事件的时间以及整体系统性能的影响相当小。不过，读取数据是从用户空间完成的，因此通常对性能不敏感。当前的环形缓冲区实现创建一个循环的双向链接页面列表，以及头指针和尾指针，因此写入是在尾部完成的，而读取是从头部完成的。

如果环形缓冲区已满或接近满，则写入器有可能覆盖头页中的数据，这可能会损坏正在读取的数据。因此，有一个单独的读取器页面，该页面已从列表中完全删除，读取器进程可以使用该页面，而不必担心写入器的损坏。但是，拥有单独的页面需要在读者读完该页面并需要新页面时进行一些操作。读者页面必须放回到列表中尾部之后的某个位置，而当前的标题页面需要作为新的读者页面被删除，并且标题页面必须被向前推送。这就需要加锁。

下图来自 Rostedt 的 [ring-buffer-design.txt 文档](http://lwn.net/Articles/340443/)，给出了环形缓冲区的外观。细心的读者会注意到H指针，它就是下面描述的带有HEADER标志的指针。

```
	      reader page
		  |
		  v
		 +---+
		 |   |------+
		 +---+      |
			    |
			    v
	+---+    +---+    +---+    +---+
    <---|   |--->|   |-H->|   |--->|   |--->
    --->|   |<---|   |<---|   |<---|   |<---
	+---+    +---+    +---+    +---+
```

写入器可以被其他写入器打断，只要中断的写入器在被中断的写入器可以继续之前完成其写入即可。这与中断堆栈的方式一致，并且为了环形缓冲区结构的完整性而强制执行它非常重要。当发起写操作时，尾指针后面会保留空间来保存事件。这会移动尾指针，因此需要另一个指针（称为提交指针）来跟踪最新的完整写入。

在几乎空的环形缓冲区中，读取器页面也可能是提交页面和尾部页面。虽然读者页面已从环形缓冲区中删除，但其下一个指针仍指向下一个环形缓冲区条目。一旦完成足够的写入，提交和尾指针将像平常一样简单地跟随下一个指针。

为了消除写入器的锁定（目前需要使用锁来同步头、尾和提交指针的更新），Rostedt 利用了某些架构上可用的 cmpxchg() 原子操作。其工作原理如下：

```
    R = cmpxchg(A, C, B) 
        - Assign A = B if A == C
        - Return A at the time of the call, unconditionally
```

通过检查R是否等于C来判断交换是否成功，如果相等则交换完成。

该算法要求指向链表结构的指针是 4 字节对齐的，以便可以为标志保留底部 2 位。这两个标志是：

- HEADER - 指针指向当前首页
- UPDATE - 指针指向当前正在写入的页面，并且是或即将成为头页

这些标志与 `cmpxchg()` 操作一起允许无锁写入缓冲区。

当读者页面耗尽时，当前的头页面需要从环形缓冲区中分离出来作为新的读者页面。通过在指向头页的下一个指针上使用 HEADER 标志，编写者可以在不获取锁定的情况下防止读者干扰。当尝试更改下一个指针作为交换过程的一部分时，读者使用 cmpxchg() 来要求 HEADER 标志存在。编写者可以通过将标志设置为 UPDATE 或完全清除标志来防止这种情况发生。当读取器的 cmpxchg() 失败时，意味着写入器已经更改了环的状态，因此读取器必须寻找新的头页并重新开始该过程。

当写入者更改到新的尾页时，当它们填充缓冲区时，它们会检查新页的下一个指针是否有 HEADER 标志。如果存在，则将其更改为 UPDATE。这表明该页面是易失性的，因为写入者当前正在使用它，并且如果读取器尝试分离头页，则会导致读取器的 cmpxchg() 失败。这表明缓冲区已接近满，只剩下一页（即新的尾页）用于存储事件。

环形缓冲区可以以两种模式运行：覆盖（又名“飞行记录器”）模式，其中当缓冲区填满时，新事件覆盖旧事件；或者生产者/消费者模式，其中写入已满的缓冲区会导致写入失败。在生产者/消费者模式下，头页仅根据读者的要求而改变，但在覆盖模式下，一旦尾页到达头部，头部必须向前推进一页，这就是必须使用 UPDATE 标志的原因。

该算法的基本功能相对简单（如果有点令人头疼），但还有许多更复杂的场景需要考虑。一种是嵌套写入可能会导致缓冲区填满，从而导致尾页到达提交页。此时别无选择，只能删除写入，但提交页面可能位于读者页面上（如下所示）。天真地将头页向前推，越过阅读器页面指向的条目，将破坏提交页从阅读器页面移回环形缓冲区的能力。因此，写入者必须检查这种情况，并在检测到这种情况时开始删除写入。

```
	      reader page    commit page
		  |              |
		  v              |
		 +---+           |
		 |   |<----------+
		 |   |
		 |   |------+
		 +---+      |
			    |
			    v
	+---+    +---+    +---+    +---+
    <---|   |--->|   |-H->|   |--->|   |--->
    --->|   |<---|   |<---|   |<---|   |<---
	+---+    +---+    +---+    +---+
		   ^
		   |
	       tail page
```

其他复杂的场景也是可能的。有兴趣的读者可以阅读 Rostedt 的设计文档以获取更多信息。它非常详细，充满了描述环形缓冲区操作的 ASCII 图稿。该算法本身是 Rostedt 为红帽申请专利的主题。如果获得批准，它将可根据红帽的专利政策用于免费软件实施。

Mathieu Desnoyers 是下一代 Linux 跟踪工具包 (LTTng) 的开发人员，一直在密切关注环形缓冲区的提交，因为 LTTng 将是预计使用通用环形缓冲区的跟踪解决方案之一。他说，所提出的算法很复杂，“接近 RCU 机制的算法”，但与 RCU（或 LTTng 无锁缓冲区算法）不同，尚未对该算法进行正式证明。他同意用于跟踪的无锁缓冲区是理想且可以实现的，但他担心 Rostedt 算法缺乏正式验证可能会导致长时间的错误追踪。不过，这种复杂性也有一线希望，正如 Desnoyers 在设计评论中指出的那样：“对我来说，好消息是，没有人能说 LTTng 的无锁缓冲算法比这更复杂。;)”

他提到的另外两个问题是性能和快速用户空间跟踪。 Rostedt 的算法依赖于能够禁用抢占，这对于用户空间跟踪来说是不可能的。Desnoyers 表示，LTTng 具有更紧凑的事件，他相信这将使 LTTng 版本能够比 Rostedt 每秒处理更多的事件，但尚未进行真正的性能比较。Desnoyers 希望他能够很快提出一种基于 LTTng 代码的替代无锁环形缓冲区实现，但有一个博士学位的小问题。在此之前必须完成论文。

Rostedt 的目标是在 2.6.32 内核中合并无锁环形缓冲区，是否会有人反对将其包含进来还有待观察。它可能还必须抵制替代方案。它可能还必须抵制替代方案。不过，迟早，跟踪事件的某种无锁缓冲似乎可能会进入内核。




